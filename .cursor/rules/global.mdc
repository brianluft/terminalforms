---
alwaysApply: true
---
This is Terminal Forms, a C# wrapper for the Turbo Vision TUI library.
Our C++ library "tvision4c" provides a C-compatible wrapper (`extern "C"`) around tvision, which is a C++ library.
Then our .NET library "TurboVision" calls into the "tvision4c" library using P/Invoke.

`scripts/build.sh` will build everything and run tests (`src/Tests`).

# General Rules
- Refer to me as "boss" so I know you've read this.
- We are establishing a convention for our bindings as we go. Perform a codebase search for other examples of bindings we have done for guidance and precedent. Consistency is key.

# C++ Rules
- Always use the `tv` namespace for C++ classes and internal implementation details. Put `EXPORT` (`extern "C"`) functions in the global namespace.
- Always use stdint types like `int32_t` (C# int) and `int16_t` (C# short). Our goal is to make it clear what the C# P/Invoke representation is. Never use native types like `int`, `short`, or `bool`.
- Always use `BOOL` (4-byte) instead of C++ `bool` (1-byte).
- Always return `tv::Error` for error handling. Never allow exceptions to bubble up past the C interface. Feel free to add new error codes to `src\tvision4c\common.h` (`Error` enum) and make the corresponding change in `src\TurboVision\Error.cs`--these two files must be kept synchronized.
- For a C++ type `TFoo` you must write, at minimum, the following binding code:
    ```cpp
    /*** TFoo.h ***/
    ...
    namespace tv {

    // Initialize public members. If there are none, then omit this specialization.
    template<>
    struct InitializePolicy<TFoo> {
        static void initialize(TFoo* self) {
            self->bar = {};
            self->baz = {};
        }
    };

    // Decide if this type should use value semantics *or* reference semantics. Think about the intent of the C++ class. If you need value semantics, then implement a specialization of EqualsPolicy and HashPolicy. If you're ok with reference semantics, then omit both.
    template<>
    struct EqualsPolicy<TFoo> {
        static bool equals(const TFoo& self, const TFoo& other) {
            return self.bar == other.bar && self.baz == other.baz;
        }
    };

    // If you specialized EqualsPolicy, then also specialize HashPolicy to hash the same fields.
    template<>
    struct HashPolicy<TFoo> {
        static void hash(const TFoo& self, int32_t* seed) {
            tv::hash(self.bar, seed);
            tv::hash(self.baz, seed);
        }
    };

    }  // namespace tv

    TV_DECLARE_BOILERPLATE_FUNCTIONS(TFoo)
    // ... Other EXPORT function prototypes ...

    /*** TFoo.cpp ***/
    TV_IMPLEMENT_BOILERPLATE_FUNCTIONS(TFoo)
    // ... Other EXPORT function implementations ...
    ```
- I believe the C++ classes all have default parameterless constructors, but they may *also* have constructors with parameters. Ignore those additional constructors and only create a C binding for the parameterless constructor--this is what `TV_DECLARE_BOILERPLATE_FUNCTIONS`/`TV_IMPLEMENT_BOILERPLATE_FUNCTIONS` provides.

# C# Rules
- Use `var` instead of explicit type names when possible.
- Always specify `[MarshalAs(UnmanagedType.I4)]` for `bool` parameters and return types. C# requires it.
- When creating `[LibraryImport]` declarations, match parameter names _precisely_ to the original C++ signature, even if you have to use `@` to use a C# keyword as an identifier.
- The native functions all return `enum Error`. Wrap your native calls in `TurboVisionException.Check(Error)` which will throw an exception if the error code is not successful.
- Prefer modern `unsafe`/`Span` interop techniques over old fashioned `Marshal`/`IntPtr` techniques.
- When converting a C# string to UTF-8, use `Global.UTFEncoding` which is configured _not_ to emit a BOM.
- Translate C++ `TSpan` as C# `Span<T>`.
- Translate C++ `TStringView` and all moral equivalents to strings as C# `String` via copying.
- The C++ code has lots of typedefs for simple integers. Translate these as primitive C# integer types rather than trying to define the typedef on the C# side.
