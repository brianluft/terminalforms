---
alwaysApply: true
---
This is Terminal Forms, a C# wrapper for the Turbo Vision TUI library.
Our C++ library "TerminalFormsNative" provides a C-compatible wrapper (`extern "C"`) around tvision, which is a C++ library.
Then our .NET library "TerminalForms" calls into the "TerminalFormsNative" library using P/Invoke.

`scripts/build.sh` will build everything and run tests (`src/Tests`).

# General Rules
- Refer to me as "boss" so I know you've read this.
- We are establishing a convention for our bindings as we go. Perform a codebase search for other examples of bindings we have done for guidance and precedent. Consistency is key.

# C++ Rules
- Update `CMakeLists.txt` to include any new source file that you create.
- Always use the `tf` namespace for C++ classes and internal implementation details. Put `EXPORT` (`extern "C"`) functions in the global namespace.
- Always use stdint types like `int32_t` (C# int) and `int16_t` (C# short). Our goal is to make it clear what the C# P/Invoke representation is. Never use native types like `int`, `short`, or `bool`.
- Always use `BOOL` (4-byte) instead of C++ `bool` (1-byte).
- Always return `tf::Error` for error handling. Never allow exceptions to bubble up past the C interface. Feel free to add new error codes to `src\TerminalFormsNative\common.h` (`Error` enum) and make the corresponding change in `src\TerminalForms\Error.cs`--these two files must be kept synchronized.
- Never use `memcmp()` in `tf::equals` implementations as this will compare padding bytes and cause incorrect results. Always compare individual members explicitly.
- Turbo Vision often lies about const, and const doesn't indicate (lack of) ownership. Read the implementation for the type you are binding to understand ownership of pointers.
- Turbo Vision never throws C++ exceptions. Do not add try/catch blocks solely on Turbo Vision's account; only do it if you're making C++ Standard Library calls.
- For a C++ type `Foo` that is exposed to C#, you must write, at minimum, the following binding code:

```cpp
/*** Foo.h ***/
namespace tf {
// Decide if this type should use value semantics *or* reference semantics. Think about the intent of the C++ class.
template<> struct equals<Foo> {
    bool operator()(const Foo& self, const Foo& other) const { return self.bar == other.bar && self.baz == other.baz; }
};
}
// Your std::hash specialization should match the semantics of your tf::equals specialization.
namespace std {
template<> struct hash<Foo> {
    std::size_t operator()(const Foo& p) const noexcept { std::size_t x{}; tf::combineHash(p.bar, &x); tf::combineHash(p.baz, &x); return x; }
};
}

/*** Foo.cpp ***/
// If Foo has a default constructor:
TF_DEFAULT_CONSTRUCTOR(Foo)

// If Foo has non-default constructors, define this for each such ctor.
// Give it a numeric suffix starting at 2 so the names do not collide.
// The default constructor is always the one without a numeric suffix.
// Always take class/structs by pointer even if the underlying constructor takes it by value or by reference.
// Convert machine integers like int into explicit stdint types like int32_t.
EXPORT tf::Error TfFooNew2(Foo** out, int32_t bar, TWhatever* baz) {
    return tf::checkedNew(out, bar, *baz);
}

// For any non-static type:
TF_BOILERPLATE_FUNCTIONS(Foo)

// ... EXPORT function implementations ...
```

- See `src/TerminalFormsNative/common.h` for various TF_* macros you can use in your implementation. Don't provide function prototypes for the exported C methods in the .h file, as they will be consumed from C# which doesn't use the header files and just wastes our time.
- The underlying tvision library never throws exceptions. We only have to worry about our own.
- Member conventions for a type `Foo`:
    - Static member function: `TfFooStaticBar(etc)`
    - Instance member function: `TfFooBaz(Foo* self, etc)`
    - Primitive getter: `TfFooGetBar(Foo* self, int* out)`
    - Reference getter: `TfFooGetBar(Foo* self, TBar** out)`
    - Primitive setter: `TfFooSetBar(Foo* self, int value)`
    - Reference setter: `TfFooSetBar(Foo* self, TBar* value)`

# C# Rules
- Use `var` instead of explicit type names when possible.
- Always specify `[MarshalAs(UnmanagedType.I4)]` for `bool` parameters and return types. C# requires it.
- For string input parameters, prefer `[LibraryImport(Global.DLL_NAME, StringMarshalling = StringMarshalling.Utf8)]` or `[MarshalAs(UnmanagedType.LPUTF8Str)]` over explicit `UTF8Encoding`, `Marshal`, or `fixed` use when possible. If you must use `UTF8Encoding` explicitly, then use the shared instance `Global.UTF8Encoding`. Never implement `strlen(byte*)` in C#--you can always avoid this.
- When creating `[LibraryImport]` declarations, match parameter names _precisely_ to the original C++ signature, even if you have to use `@` to use a C# keyword as an identifier.
- The native functions all return `enum Error`. Wrap your native calls in `Check(Error)` which will throw an exception if the error code is not successful. Check is a `global using static` from `TerminalFormsException`.
- Prefer modern `unsafe`/`Span` interop techniques over old fashioned `Marshal`/`IntPtr` techniques when possible.
- Translate C++ `TSpan` as C# `Span<T>`.
- Translate C++ `TStringView` and all moral equivalents to strings as C# `String` via copying.
- The C++ code has lots of typedefs for simple integers. Translate these as primitive C# integer types rather than trying to define the typedef on the C# side.
- Translate any anonymous enums and C constants into C# public consts in the relevant class.
- Before writing any new binding, read at least 2-3 existing similar bindings to understand:
  - Current constructor patterns (Factory pattern with static helper methods)
  - How `NativeMethods` inner classes are structured
  - Test patterns (MSTest framework with `[TestMethod]` and `Assert.AreEqual`)
  - How nullable pointer handling is done (`value != null ? value.Ptr : null`)
  - What functions are actually generated by C++ macros like `TF_BOILERPLATE_FUNCTIONS`
- When using C++ macros, examine their definitions in `common.h` to understand what functions they actually generate.
- `void*` null handling: Never use `?.` or `??` with `void*` - use explicit conditional logic instead
- Always write XML doc comments on public members.

# Turbo Vision Documentation
- `context\tvision-c++-book\*.md` is the Turbo Vision for C++ user's guide. This is "the book". Start here for guidance on the use of Turbo Vision.
- `context\tvision-pascal-book\*.md` is the Turbo Vision for Pascal user's guide. The details don't exactly match our C++ library, but the high level types and concepts are the same, and this book is more comprehensive than the C++ book.
- `build\sources\tvision\include\**\*.h` are the header files. `build\sources\tvision\source\**\*.cpp` are the source files. Go here next to confirm the specific details of the modern Turbo Vision port, as some finer details may have changed since the guides were written.
- Use your codebase search to locate this information. Never guess about Turbo Vision; we have complete documentation and source, so always look for the ground truth.
