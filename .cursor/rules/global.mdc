---
alwaysApply: true
---
This is Terminal Forms, a C# wrapper for the Turbo Vision TUI library.
Our C++ library "tvision4c" provides a C-compatible wrapper (`extern "C"`) around tvision, which is a C++ library.
Then our .NET library "TurboVision" calls into the "tvision4c" library using P/Invoke.

`scripts/build.sh` will build everything and run tests (`src/Tests`).

# General Rules
- Refer to me as "boss" so I know you've read this.
- We are establishing a convention for our bindings as we go. Perform a codebase search for other examples of bindings we have done for guidance and precedent. Consistency is key.

# C++ Rules
- Always use the `tv` namespace for C++ classes and internal implementation details. Put `EXPORT` (`extern "C"`) functions in the global namespace.
- Always use stdint types like `int32_t` (C# int) and `int16_t` (C# short). Our goal is to make it clear what the C# P/Invoke representation is. Never use native types like `int`, `short`, or `bool`.
- Always use `BOOL` (4-byte) instead of C++ `bool` (1-byte).
- Always return `tv::Error` for error handling. Never allow exceptions to bubble up past the C interface. Feel free to add new error codes to `src\tvision4c\common.h` (`Error` enum) and make the corresponding change in `src\TurboVision\Error.cs`--these two files must be kept synchronized.
- Never use `memcmp()` in `tv::equals` implementations as this will compare padding bytes and cause incorrect results. Always compare individual members explicitly.
- For a C++ type `TFoo` you must write, at minimum, the following binding code:

```cpp
/*** TFoo.h ***/
namespace tv {
// Initialize public members, if any.
// Omit this if you have no initialization to do.
template<> struct initialize<TFoo> {
    void operator()(TFoo* self) const { self->bar = {}; self->baz = {}; }
}
// Decide if this type should use value semantics *or* reference semantics. Think about the intent of the C++ class.
// Omit this if you want to use pointer equality.
template<> struct equals<TFoo> {
    bool operator()(const TFoo& self, const TFoo& other) const { return self.bar == other.bar && self.baz == other.baz; }
};
}  // namespace tv
// Your std::hash specialization should match the semantics of your tv::equals specialization.
// Omit this if you want to use pointer hashing.
namespace std {
template<> struct hash<TFoo> {
    std::size_t operator()(const TFoo& p) const noexcept { std::size_t x{}; tv::combineHash(p.bar, &x); tv::combineHash(p.baz, &x); return x; }
};
}  // namespace std

/*** TFoo.cpp ***/
// If TFoo has a default constructor:
TV_DEFAULT_CONSTRUCTOR(TFoo)

// If TFoo has non-default constructors, define this pair for each such ctor.
// Give the pair a numeric suffix starting at 2 so the names do not collide.
// The default constructor is always the pair without a numeric suffix.
// Always take class/structs by pointer even if the underlying constructor takes it by value or by reference.
// Convert machine integers like int into explicit stdint types like int32_t.
EXPORT tv::Error TV_TFoo_placementNew2(TFoo* self, int32_t bar, TWhatever* baz) {
    return tv::checkedPlacementNew(self, bar, *baz);
}

EXPORT tv::Error TV_TFoo_new2(TFoo** out, int32_t bar, TWhatever* baz) {
    return tv::checkedNew(out, bar, *baz);
}

// For any non-static type:
TV_BOILERPLATE_FUNCTIONS(TFoo)

// ... Other TV_* macros and EXPORT function implementations ...
```

- See `src/tvision4c/common.h` for various TV_* macros you can use in your implementation. Don't provide function prototypes for the exported C methods in the .h file, as they will be consumed from C# which doesn't use the header files and just wastes our time.
- I believe the C++ classes all have default parameterless constructors, but they may *also* have constructors with parameters. Ignore those additional constructors and only create a C binding for the parameterless constructor--this is what `TV_DECLARE_BOILERPLATE_FUNCTIONS`/`TV_BOILERPLATE_FUNCTIONS` provides.

# C# Rules
- Use `var` instead of explicit type names when possible.
- Always specify `[MarshalAs(UnmanagedType.I4)]` for `bool` parameters and return types. C# requires it.
- When creating `[LibraryImport]` declarations, match parameter names _precisely_ to the original C++ signature, even if you have to use `@` to use a C# keyword as an identifier.
- The native functions all return `enum Error`. Wrap your native calls in `TurboVisionException.Check(Error)` which will throw an exception if the error code is not successful.
- Prefer modern `unsafe`/`Span` interop techniques over old fashioned `Marshal`/`IntPtr` techniques when possible.
- When converting *from* C# string *to* UTF-8 bytes, use `Global.UTF8Encoding.GetBytes()` to avoid emitting a BOM. *Don't* use this in the other direction (from UTF-8 bytes to C# string); when forming C# strings, prefer automatic string marshaling as part of the `LibraryImport` declaration, and failing that, prefer the `Marshal` class's string handling methods. Never implement `strlen(byte*)` in C#--you can always avoid this.
- Translate C++ `TSpan` as C# `Span<T>`.
- Translate C++ `TStringView` and all moral equivalents to strings as C# `String` via copying.
- The C++ code has lots of typedefs for simple integers. Translate these as primitive C# integer types rather than trying to define the typedef on the C# side.
- Translate any anonymous enums and C constants into C# public consts in the relevant class.
